---
layout: post
title: "[JAVA] JPA 연관관계"
subtitle: ' About JPA Relation'
author: "JongMin-Lee"
header-style: text
header-mask: 0.3
comments: true
catalog:  true
tags:
  - JPA
  - JAVA
  - Spring Boot
---

이번에는 연관관계에 대해 보겠습니다.  
연관관계에는 **단방향**과 **양방향**이 있습니다. 차례대로 살펴 보겠습니다.

## 1. 단방향 매핑
지금 현재 **Member**객체와 **Club**객체가 있습니다.
<img src="/img/in-post/jpa4/relation1.png">

> 보기 편하기 위해서 다른 컬럼들은 제외했습니다.  

**Club**에 여러 **Member**가 가입할 수 있다고 해보겠습니다. 그럼 1:N의 관계가 성립합니다.
<img src="/img/in-post/jpa4/relation2.png">

다음과 같은 관계가 성립됩니다. 그럼 Code로 보겠습니다.
```java
@Entity
@Getter @Setter
public class Member {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long member_id;

    private String name;
    private int age;

    @Enumerated(value = EnumType.STRING)
    private RoleType roleType;

    @Embedded
    private Friend friends;

    @ManyToOne
    @JoinColumn(name = "club_id")
    private Club club;

    public Member(){}

    Member(String name, int age, Friend friend){
        this.name = name;
        this.age = age;
        this.friends = friend;
    }

}
```
현재 구분을 편하게 하기 위해서 **Member**와 **Club**의 id앞에 각자의 클래스 이름을 추가해 놨습니다.  
두 테이블을 연결하기 위해 **@ManyToOne** 어노테이션을 사용했습니다. **@JoinColumn**으로 'club_id'를 지정해서 **Club** 객체의 id와 조인한다고 설정이 되었습니다. 그러면 테스트를 진행해 보겠습니다.
```java
public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);

        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory("jongmin");
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();

        // 트랜잭션 시작
        transaction.begin();
        try{
            Club club = new Club("baskball");
            entityManager.persist(club);

            Friend friend = new Friend("park", "01022221111");
            Member member = new Member("jongmin", 30, friend);
            member.setClub(club);
            entityManager.persist(member);

            Member findMember = entityManager.find(Member.class, member.getMember_id());
            Club findClub = findMember.getClub();
            System.out.println("Club Name : " + findClub.getClubName());

            transaction.commit(); // 커밋
        }catch (Exception e){
            transaction.rollback();
        }finally {
            entityManager.close();
        }
        entityManagerFactory.close();
    }
```
**Club**을 먼저 만들어서 **Member**객체에 넣은 후 각각 저장을 실행합니다. 그 후에 `find()`를 통해서 **Member**객체를 불러온 후 **Member**객체 안의 **Club**를 확인해 보면 저장했던 **Club**가 나오는 것을 확인할 수 있습니다. **Club**을 조회하는 어떠한 것도 하지 않았는데 어떻게 조회가 될 수 있었을 까요?  
`@ManyToOne`으로 매핑되어 있었기 때문에 **Club**를 조회해서 가져온 것입니다. 그 결과 우리는 **Member**객체만 가져온다면 저장할 때 설정한 **Club**를 알아서 가져오는 편리한 경험을 하게 됩니다.
<img src="/img/in-post/jpa4/relation3.png">

**Member**의 'CLUB_ID'에는 **Club**의 'id'가 저장된 것을 확인할 수 있습니다. 저희가 **@JoinColumn**에 'club_id'를 지정했기 때문입니다.  
그렇다면 항상 **Member**를 조회하면 **Club**를 같이 조회해서 가져오는 것일까요? 그렇지 않습니다. **@ManyToOne** 어노테이션에는 속성이 존재합니다.
- FetchType.LAZY : **Club**가 **Member**를 통해 사용될 때 조회됩니다.
- FetchType.EAGER : 무조건 같이 가지고 옵니다.(default)

보통은 **FetchType.LAZY**의 사용을 권장합니다. 그러나 둘이 연관되어 사용하는 일이 많다면 **FetchType.EAGER**를 사용해도 괜찮다고 생각합니다.

## 2. 양방향 매핑

양방향 매핑에서는 **Member**가 여러 **Club**에 가입할 수 있고, **Club**또한 여러명의 **Member**를 가질 수 있다고 가정하겠습니다.  
JPA에서의 양방향 매핑은 데이터베이스와는 다른 형태입니다.
<img src="/img/in-post/jpa4/relation4.png">
데이터베이스의 관계와 다른점을 눈치 채셨나요??  
데이터베이스에서 M:N이어도 연결된은 선은 하나입니다. 그러나 위의 사진을 보면 연결되는 선이 2개임을 볼 수 있습니다. 그 이유는 JPA에서의 양방향은 `단방향+단방향`이기 때문입니다.  
좀 더 이해하기 쉽게 하기 위해서 데이터베이스 이론을 공부하다 보면 **M:N**을 해결하는 방법으로 **1:N 과 N:1**의 조합으로 바꾸는 걸 생각해 보실수 있습니다.
<img src="/img/in-post/jpa4/relation5.jpg">
<center>참고: 위키피디아</center>

저희는 위에서 **Member**에서 **Clob**로 가는 매핑은 설정을 했습니다. 그렇다면 이번에는 **Clob**에서 **Member**로 가는 매핑을 설정해보겠습니다.  
> 데이터베이스와 JPA의 차이점이 여기서 나타납니다.  
> 데이터베이스에서는 한쪽이 연결되면 다른쪽에서도 참조가 가능합니다. 예를들어 Member와 Club이 연결되었다면 서로 JOIN하여 검색이 가능합니다. 그러나 JPA에서는 위의 설정만 가지고 Member에서 Club은 참조가 가능하나 Club에서는 Member를 참조할 수가 없습니다.

```java
@Entity
@Getter @Setter
public class Club {

    @Id
    @GeneratedValue
    Long club_id;

    String clubName;

    @OneToMany(mappedBy = "club")
    List<Member> memberList = new ArrayList<Member>();

    public Club(){}

    public Club(String clubName){
        this.clubName = clubName;
    }

}
```
**Club** Entity에 **@OneToMany**를 추가하여 **Member**와 단방향 연결을 하였습니다. 먼저 실습 후 양방향관계에 대해서 더 알아보겠습니다.
```java
 public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);

        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory("jongmin");
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();

        // 트랜잭션 시작
        transaction.begin();
        try{
            Club club = new Club("baskball");
            entityManager.persist(club);

            Friend friend = new Friend("park", "01022221111");
            Member member = new Member("jongmin", 30, friend);
            member.setClub(club);
            entityManager.persist(member);

            entityManager.flush();
            entityManager.clear();

            Member findMember = entityManager.find(Member.class, member.getMember_id());
            Club findClub = findMember.getClub();
            System.out.println("Club Name : " + findClub.getClubName());

            List<Member> members = findClub.getMemberList();
            for(Member member1 : members){
                System.out.println("Member Name : " + member1.getName());
            }

            transaction.commit(); // 커밋
        }catch (Exception e){
            transaction.rollback();
        }finally {
            entityManager.close();
        }
        entityManagerFactory.close();

    }
```
이전의 단방향 코드에서 `List<Member> members = findClub.getMemberList();`를 통해서 **MemberList**가 출력되는지 확인 하는 코드가 추가 되었습니다.(flush()와 clear()가 추가 되었는데 이후의 장에서 설명하겠습니다.)  
콘솔창을 확인해 보시면 **Member** Entity에 저장한 **'jongmin'**이 출력되는 것을 볼 수 있습니다.


