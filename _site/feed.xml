<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jongmin's Blog</title>
    <description>description</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 15 Jun 2019 13:03:51 +0900</pubDate>
    <lastBuildDate>Sat, 15 Jun 2019 13:03:51 +0900</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>[Java] Static 완전정복!! (2)</title>
        <description>&lt;h1 id=&quot;들어가며&quot;&gt;들어가며&lt;/h1&gt;

&lt;p&gt;저번 글에서는 static에 대해 간단하게 알아보았습니다.
(안보고 오셧다면 여기로! -&amp;gt; &lt;a href=&quot;http://JongMinLee0.github.io/2019/06/15/static1/&quot;&gt;static 완전정복(1&lt;/a&gt;))&lt;/p&gt;

&lt;p&gt;지금까지의 내용을 요약해보자면 &lt;code class=&quot;highlighter-rouge&quot;&gt;프로그램이 실행될 때 Java메모리에 할당되며, 프로그램이종료될 때 해체된다.&lt;/code&gt;
또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;main메소드에서 사용하는 이유는 JVM에 편의를 제공하기 위함&lt;/code&gt;이라 할 수 있겠습니다.&lt;/p&gt;

&lt;p&gt;이번에는 static을 사용하는 다양한 경우에 대해 보겠습니다!!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;static초기화-블록initailization-block&quot;&gt;Static초기화 블록(Initailization BLock)&lt;/h2&gt;
&lt;h2 id=&quot;static-변수variables&quot;&gt;Static 변수(Variables)&lt;/h2&gt;
&lt;h2 id=&quot;static-메소드&quot;&gt;Static 메소드&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/java-static-keyword1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이들은 클래스의 static 멤버 또는 구성요소 입니다. 이들은 액세스 하기 위해서 객체를 만들 필요가 없습니다.
즉, 직접 클래스의 이름을 사용하여 액세스 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Static 초기화 블록은 Static 변수만을 초기화하는 이름없는 블록입니다. 다음과 같은 형태를 가집니다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Set of Statements&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;아래의 코드를 보며 이들의 동작을 자세히 알아 봅시다!!&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StaticComponents&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;staticVariables&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;StaticComponents SIB&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;staticVariable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;staticMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;From StaticMethod&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;staticVariable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;MainClass SIB&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Static Members directlyaccessed with Class Name&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;StaticComponents&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;staticVariable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;StaticComponents&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;staticMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;1단계&quot;&gt;1단계&lt;/h4&gt;

&lt;p&gt;Java MainClass 를 트리거하면 Java명령은 할당된 메모리를 Stack과 Heap으로 나누게 됩니다. 자바 명령어는 Stack메모리에 들어가 실행되며, MainCalss가 heap메모리에 있는지 없는지 확인합니다.
만약 heap에 없다면 load하는 작업을 수행합니다.
그렇게 되면 MainClass는 무작위로 조금의 메모리를 할당받게 됩니다. 이것을 Class Memory라 부릅니다.
모든 static멤버는 이 Class메모리에 load됩니다. MainClass 안에는 오직 하나의 static 메소드(main)만 있기 때문에 이것을 MainClass의 Class메모리에 load시킵니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2단계&quot;&gt;2단계&lt;/h4&gt;

&lt;p&gt;모든 static 멤버를 load한 후 정적 초기화 블록(SIB: Static Initailization Blocks)이 실행됩니다. 이들은 임무를 수행한 후 저장되지 않습니다. 다음을 보면 확실하게 알 수 있습니다!&lt;/p&gt;

&lt;p&gt;Main()메소드를 로드한 후 MainClass의 SIB는 실행을 위해 Stack에 들어갑니다. 여기서 SIB에는 하나의 문장만 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;MainClass SIB&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 부분을 실행해서 ‘MainClass SIB’를 콘솔창에 띄운 후 Stack메모리에서 벗어납니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3단계&quot;&gt;3단계&lt;/h4&gt;

&lt;p&gt;이제 java command(자바 명렁어)는 실행을 위해 main메소드를 호출합니다.(main메소드가 스택에 들어갑니다.)
가장 먼저 &lt;code class=&quot;highlighter-rouge&quot;&gt;StaticComponents.staticVariable=20;&lt;/code&gt; 가 실행됩니다.
여기서 먼저 StaticComponents 클래스가 메모리에 load되었는지 확인합니다.
load되어 있지 않으면 먼저 load작업을 수행합니다. 임의의 메모리가 StaticComponents클래스에 할당되면 StaticComponents의 모든 정적 멤버(변수, 메소드)가 Class 메모리에 load됩니다. StaticVariable은 전역변수이고 기본값은 0(초기화)으로 할당됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4단계&quot;&gt;4단계&lt;/h4&gt;

&lt;p&gt;StaticComponents의 모든 static 멤버를 load하면 SIB가 실행됩니다. 마찬가지로
StaticComponents클래스의 SIB가 실행을 위해 Static에 들어갑니다. 가장 먼저 &lt;code class=&quot;highlighter-rouge&quot;&gt;System.out.println(&quot;StaticComponents SIB&quot;);&lt;/code&gt;가 실행됩니다.
콘솔에 ‘StaticComponents SIB’을 띄운 후 staticVariable에 10이라는 값을 넣어 줍니다. 이제 다른 명령문이 없으므로 스택 메모리에 남겨 둡니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5단계&quot;&gt;5단계&lt;/h4&gt;

&lt;p&gt;이제 main()메소드로 돌아옵니다. 이제 staticVariable변수에 20의 값을 할당해주는 명령이 실행됩니다.
그 다음 staticMethod()를 호출합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;6단계&quot;&gt;6단계&lt;/h4&gt;

&lt;p&gt;호출된 staticMethod()는 실행을 위해 stack에 들어갑니다. 첫 번째 문장을 수행하여 콘솔에 ‘From staticMethod’을 출력한 후 staticVariable의 값 20을 출력합니다.
더 이상 명령문이 남아 있지 않기 때문에 stack을 떠납니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;7단계&quot;&gt;7단계&lt;/h4&gt;

&lt;p&gt;다시 main()으로 돌아오면 더이상 수행할 명령어가 남아있지 않습니다. 따라서 main()메소드와 java command는 stack을 떠납니다.&lt;/p&gt;

&lt;p&gt;위의 과정을 그림으로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/static.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;출력순서는 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;MainClass SIB
StaticComponents SIB
From StaticMethod
20
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;마치며&quot;&gt;마치며&lt;/h1&gt;
&lt;p&gt;사실 Static은 이보다 더 많은 곳에 사용이 됩니다. 예를 들어 final을 활용하거나,
import할 때도 사용이 됩니다. 그러나 지금까지의 글을 알고 있다면 어느 곳에서 사용이 되도 
이 붙은 static이 무엇을 의미하는지, static이 붙음으로써 변수, 메소드가 어떠한 의미를 갖게 되는지 알 수 있을 것입니다. 부족한 글이지만 읽어주셔서 감사합니다!!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;참고&quot;&gt;참고&lt;/h4&gt;
&lt;p&gt;이미지 : https://www.javatpoint.com/static-keyword-in-java&lt;/p&gt;

&lt;p&gt;https://javaconceptoftheday.com/static-members-java/&lt;/p&gt;

</description>
        <pubDate>Sat, 15 Jun 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/06/15/static2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/15/static2/</guid>
        
        <category>Java</category>
        
        <category>Static</category>
        
        
      </item>
    
      <item>
        <title>[Java] Static 완전정복!! (1)</title>
        <description>&lt;h2 id=&quot;들어가며&quot;&gt;들어가며&lt;/h2&gt;

&lt;p&gt;Java를 처음 접하고 가장 먼저 적었던 코드가 있습니다. 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;public static void main(String[] args)&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;책으로나 youtube로 공부할 때도 가장 앞부분에 나와 시작부터 당황시켰던 녀석입니다.
그러나 일단 저렇게 시작을 한다 알아두기만 하라고 해서 넘어갔던 부분이기도 하죠…&lt;/p&gt;

&lt;p&gt;이 후 Java를 공부하면서 static 이라는 단어가 심심치 않게 나오며 여러부분에서 사용되는 것을 볼 수 있었습니다. 또한 많은 곳에 설명이 되어 있지만 히해하기 어려운 글이 많기도 합니다.
도대체 이 static이 뭔지 나름대로 정리해봤습니다!!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-main-method&quot;&gt;1. main() method&lt;/h2&gt;

&lt;p&gt;처음 접하는 코드가 위에 말했던 것처럼 main method에서의 static 입니다. 그렇다면 먼저
main method에 대해 알아봅시다.&lt;/p&gt;

&lt;p&gt;Java에서 main() method는 JVM(Java Virtual Machine)의 Java 프로그램 진입점입니다. 그말인 즉, JVM은 main()메소드를 호출하여 자바 프로그램을 시작한다는 것 입니다.
(&lt;a href=&quot;https://jongminlee0.github.io/2019/06/13/jvm/&quot;&gt;JVM이란?&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-static&quot;&gt;2. Static&lt;/h2&gt;

&lt;p&gt;static은 keyword입니다. 메서드 및 변수 앞에 static을 추가하면 instance 메소드 및 변수 대신
class 메소드 및 class 변수가 각각 만들어 집니다.
따라서 static 메소드 및 변수는 Class를 사용하여 직접 액세스 할 수 있습니다. 즉 static
메소드 또는 변수를 액세스 하기 위해 객체를 생성할 필요가 없다는 말입니다.&lt;/p&gt;

&lt;p&gt;다른 말로 &lt;code class=&quot;highlighter-rouge&quot;&gt;프로그램이 실행될 때 Java 메모리에 할당되며, 프로그램이 종료될 때 해제된다.&lt;/code&gt;라 말할 수 있습니다. 어떤 말인지 이해하기 힘든 부분들이 있으니 밑에서 코드를 보며 확인해 보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;1-static-method&quot;&gt;(1) static method&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;//static function&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Calling a static function&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;메소드가 static키워드로 선언되면 이를 static 메소드(정적메소드)라고 합니다. Test.func()과 같이 개체를 참조하지 않고 액세스 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;2-static-main-method&quot;&gt;(2) static main method&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에는 일반적인 main메소드 입니다. 이 main메소드에는 왜 static이 필요한지 봅히다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;static main메소드는 JVM이 Java Application을 시작하기 위해 JVM을 호출하는 것을 명확하게 합니다. 그렇지 않으면 JVM이 응용프로그램을 시작하기 위해 각 Java응용프로그램 빌드에 대한 항목을 지정해야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이 static main메소드는 정적(static)인데 그렇지 않으면 생성자를 호출해야하는 모호성이 있기 때문입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 &lt;strong&gt;모호성&lt;/strong&gt;에 대해 잠시 보겠습니다!&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 코드를 살펴봅시다. JVM은 새로운 &lt;strong&gt;Test(int t)&lt;/strong&gt;를 호출해야하는지 여부를 경정하는 모호성 상태에 들어갑니다.
그렇다면 t에 어떤 값을 전달해야 할까요? 그렇지 않다면 생성자를 실행하지 않고 JVM이 Test를 인스턴스화 해야 할까요?&lt;/p&gt;

&lt;p&gt;진입점이 호출되기 전에 JVM이 클래스를 인스턴스화 해야하는 것은 너무많은 edge case와 모호성이 있습니다. 이것이 main메소드가 static(정적)인 이유입니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;edge case란?
알고리즘이 처리하는 데이터의 값이 알고리즘의 특성에 따른 일정한 범위를 넘을 경우에 발생하는 문제를 가리킨다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;또 한가지, main메소드가 static이므로써 JDK(Java Development Kit)에 편의를 제공해 줍니다.
만약 main메소드가 static이 아니라면 여러 IDE에서 프로젝트의 ‘실행가능한’ 클래스를 자동감지하는 것이 더욱 어려워 집니다.
따라서 관례적으로 메인 메소드를 ‘public static void main(String[] args)’로써 사용하는 것 입니다.&lt;/p&gt;

&lt;p&gt;여기까지가 main메소드에서의 static이었습니다. 다음에는 static에 대해 더 자세히 알아봅시다!!!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 15 Jun 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/06/15/static1/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/15/static1/</guid>
        
        <category>Java</category>
        
        <category>Static</category>
        
        
      </item>
    
      <item>
        <title>[Java] JVM이란 ?</title>
        <description>&lt;h1 id=&quot;jvm&quot;&gt;JVM&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;JVM(Java Virtual Machine)&lt;/strong&gt;은 Java를 다루는 사람이라면 실력을 막론하고 들어본 이름입니다.
바로 Java 언어의 특징 중 ‘운영체제(OS / platform)에 독립적이다’의 주인공입니다.
사실 저는 JVM 자바 가상 머신 즉, 가상으로 자바 코드를 돌리기 때문에 독립적이다라고만 알고 있엇고, 그 안에 메모리가 있는지 조차 알지 못했습니다. 때문에!! 이번에 확실하게 JVM에 대해 알아보고자 합니다!!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-정의&quot;&gt;1. 정의&lt;/h2&gt;

&lt;p&gt;JVM은 다른 프로그램을 실행하는 것을 목적으로 하는 프로그램 입니다. 즉, Java코드에 있는
main메소드를 실제로 호출하는 것 입니다.
JVM은 두 가지의 기본 기능이 있습니다. 첫 번째는 Java 프로그램이 모든 장치 또는 운영체제에서 실행되도록 허용하는 기능, 두 번재는 프로그램 메모리를 관리하고 최적화 하는 기능입니다. &lt;br /&gt;
정리하자면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;기술적 정의&lt;/strong&gt; : JVM은 코드를 실행하고 해당 코드의 런타임 환경을 제공하는 소프트웨어 프로그램 사양(specification)입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;일상적인 정의&lt;/strong&gt; : JVM은 Java 프로그램을 실행하는 방법입니다. JVM의 설정을 구성한 다음 실행 중에 프로그램 리소스를 관리 하는데 의존합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 개발자가 JVM에 관해 이야기 한다면 Java app의 리소스 사용을 나타내고 제어하는 시스템, 특히 서버에서 실행되는 프로세스를 의미 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-구조&quot;&gt;2. 구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/JVM.jpg&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-class-loader&quot;&gt;(1) Class Loader&lt;/h3&gt;
&lt;p&gt;클래스 로더란 runtime에 Class를 로딩하게 해주는 기술입니다. Java의 모든 것이 Class이며, 모든 Java애플리캐이션은 Class로 구성됩니다. 
응용 프로그램은 하나 또는 수천개의 클래스로 구성될 수 있습니다. Java 애플리케이션을 실행하려면 JVM은 컴파일된 .class파일을 액세스 할 수 있는 서버와 같은 Context에 load해야 합니다. 
따라서 JVM은 클래스 로더에 의존하여 기능을 수행합니다.&lt;/p&gt;

&lt;p&gt;클래스 로더의 핵심 적인 기능은 3가지 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Loading&lt;/li&gt;
  &lt;li&gt;Linking&lt;/li&gt;
  &lt;li&gt;Initialization&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 3가지 기능을 하나하나 알아봅시다!!&lt;/p&gt;

&lt;h4 id=&quot;1-1-loading&quot;&gt;(1-1) Loading&lt;/h4&gt;
&lt;p&gt;클래스 로드는 .class 파일을 읽고 해당 byte data를 생성한 다음 method영역에 저장합니다.
각 .class파일에 method영역 정보를 저장합니다. 이 정보에는 다음과 같은 것들이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;.class파일이 class 또는 interface, Enum과 관련이 있는지 여부&lt;/li&gt;
  &lt;li&gt;load된 class 및 부모 클래스의 정규화된 이름&lt;/li&gt;
  &lt;li&gt;modifier, variable, method의 정보 등등..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;.class 파일을 로드 한 후 JVM은 Class 유형의 객체를 생성하여 힙 메모리에 저장합니다.
이 객체는 java.lang 패키지에 미리 정의된 Class 유형입니다. 이 Class 객체는 사용자가 정보를 얻는 과정에 많은 편의를 제공해 줍니다.
만약 이 객체의 참조를 얻으려면 getClass( ) 메소드를 사용하여 얻을 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;1-2-linking&quot;&gt;(1-2) Linking&lt;/h4&gt;
&lt;p&gt;verification(확인), preparation(준비), resolution(해결)을 수행합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;verification&lt;/strong&gt; : 
.class파일의 정확성을 보장합니다. 이 파일의 형식이 올바른지, 유효한 컴파일러에 의해 생성되었는지를 확인합니다.
    &lt;blockquote&gt;
      &lt;p&gt;확인에 실패하면 런타임 에러 발생 (java.lang.VerifyError)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;preparation&lt;/strong&gt; :
클래스 변수에 메모리를 할당하고 메모리를 기본값으로 초기화 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;resolution&lt;/strong&gt; :
직접참조(direct reference)를 기호참조(symbolic reference)로 바꾸는 프로세스 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1-3-initialization&quot;&gt;(1-3) Initialization&lt;/h4&gt;
&lt;p&gt;초기화 단계에서 모든 static 변수는 클래스 위의 계층(부모)부터 아래 계층(자식)순으로 정의된 값을 지정 받습니다.&lt;/p&gt;

&lt;h4 id=&quot;1-4-class-loader&quot;&gt;(1-4) Class Loader&lt;/h4&gt;
&lt;p&gt;Java Class Loader는 기본 클래스 로더가 3가지 있다. 간단하게 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/classLoader.JPG&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-bootstrap-class-loader&quot;&gt;(1) Bootstrap class loader&lt;/h4&gt;
&lt;p&gt;모든 JVM은 반드시 bootstrap class loader를 가지고 있어야 하며, 신뢰있는 클래스를 
로드 할 수 있어야 합니다. 핵심 Java API 클래스를 로드해 줍니다.(Java_Hoome/jre/lib)&lt;/p&gt;

&lt;h4 id=&quot;2-extension-class-loader&quot;&gt;(2) Extension class loader&lt;/h4&gt;
&lt;p&gt;bootstrap class loader의 자식 입니다. 확장 디렉토리(Java_Home/jre/lib/ext)
또는 java.ext.dirs 시스템으로 지정된 다른 디렉토리에 있는 클래스를 로드 합니다.&lt;/p&gt;

&lt;h4 id=&quot;3-systemapplication-class-loader&quot;&gt;(3) System/Application class loader&lt;/h4&gt;
&lt;p&gt;Extension class loader의 자식입니다. 내부적으로 java.class.path에 매핑된 환경 변수를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-jvm-메모리&quot;&gt;2. JVM 메모리&lt;/h2&gt;
&lt;p&gt;이번에는 JVM 메모리 영역에 대해서 알아보겠습니다.(구조에 있는 그림을 참고해주세요!!!)&lt;/p&gt;

&lt;h3 id=&quot;1-method-area&quot;&gt;(1) Method area&lt;/h3&gt;
&lt;p&gt;static 변수를 포함하여 class 이름, 메소드 및 변수 정보 등 모든 클래스 레벨의 정보가
저장됩니다. JVM에는 단 하나의 메소드 영역이 있는며, 이는 공유자원(shared resource)입니다.&lt;/p&gt;

&lt;h3 id=&quot;2-heap-area&quot;&gt;(2) Heap area&lt;/h3&gt;
&lt;p&gt;모든 객체(Object)의 정보를 저자아고 있습니다. 이 또한 하나만 존재하며 공유자원 입니다.&lt;/p&gt;

&lt;h3 id=&quot;3-stack-area&quot;&gt;(3) Stack area&lt;/h3&gt;
&lt;p&gt;Method 내에서 사용되는 값들(매개변수, 지역변수, 리턴값 등)이 저장되는 구역으로 메소드가
호출할때 LIFO(Last In Frist Out)로 하나씩 생성되고, 메소드 실행이 완료되면
LIFO형식으로 하나씩 지워집니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;각 Thread별로 하나씩 생성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;4-pc-resister&quot;&gt;(4) PC Resister&lt;/h3&gt;
&lt;p&gt;현재 실행중인 스레드(thread)의 주소를 저장합니다. 각 thread별로 별도의 PC register를 
가지고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;5-native-method-statcks&quot;&gt;(5) Native Method Statcks&lt;/h3&gt;
&lt;p&gt;Java외 언어로 작성된 Native 코드를 위한 메모리 입니다. C / C++ 등의 코드를 수행하기위한
스택입니다.&lt;/p&gt;

&lt;p&gt;그 외&lt;/p&gt;

&lt;h3 id=&quot;6-excution-engine&quot;&gt;(6) Excution Engine&lt;/h3&gt;
&lt;p&gt;클래스 로더가 로드 작업을 완료하면 JVM은 각 클래스의 코드를 실행하기 시작합니다. 실행 엔진은
이 처리를 수행합니다. .class(바이트코드)를 실행하여 할줄씩(interperter) 바이트코드를 읽습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;실행엔진은 3부분으로 분류할 수 있습니다.
Interperter, JIT(Just-In-Time Compiler, GC(Garbage Collection))&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;참고) JIT는 인터프리터의 효츌성을 높이는데 사용됩니다. 인터프리터방식과 컴파일러 방식을 혼합한 것으로 생각할 수 있습니다.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;7-jnijava-native-method-interface&quot;&gt;(7) JNI(Java Native Method Interface)&lt;/h3&gt;
&lt;p&gt;Native Method Library와 상호작용하고 실행에 필요한 Native Libarary(C, C++)를 제공하는 인터페이스 입니다.&lt;/p&gt;

&lt;h3 id=&quot;8-native-method-libraries&quot;&gt;(8) Native Method Libraries&lt;/h3&gt;
&lt;p&gt;Execution Engine에 필요한 Native Library(C, C++)의 Collection입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-메모리-관리&quot;&gt;3. 메모리 관리&lt;/h2&gt;
&lt;p&gt;Java이전에는 프로그래머가 모든 프로그램 메모리를 관리했습니다. 그러나 Java에서는 JVM에 의해서 관리가 됩니다.
JVM에서 GC(Garbage Collection)이라는 녀석이 사용하지 않는 메모리를 지속적으로 식별하고
제거하며 메모리를 관리합니다.(이 GC라는 녀석도 상당한 녀석이니 나중에 다루도록 하겠습니다!)&lt;/p&gt;

&lt;p&gt;그런데 GC가 있어서 무조건 좋은 것은 아닙니다. 초기에는 Java가 C++만큼 빠르지 않았기 떄문에
많은 비판을 받았습니다. 차츰 다양한 알고리즘과 접근법이 나와 GC의 능력이 크게 향상되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;JVM은 Java에서 가장 기본적이면서도 중요하다고 생각합니다. 처음에는 가상메모리구나 정도로 시작했다면 JVM을 이루는 구조와 기능들이 많음을 알았습니다.&lt;/p&gt;

&lt;p&gt;이 구조들의 기능들이 모여 JVM을 이루는데 각각의 구조물들 또한 다양한 구조와 기능을 이루고 있습니다.
다음에 차근차근 세세한 부분까지 알아보겠습니다!!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;참고&quot;&gt;참고&lt;/h4&gt;
&lt;p&gt;https://www.javaworld.com/article/3272244/what-is-the-jvm-introducing-the-java-virtual-machine.html&lt;/p&gt;

&lt;p&gt;https://www.geeksforgeeks.org/jvm-works-jvm-architecture/JVM&lt;/p&gt;

</description>
        <pubDate>Thu, 13 Jun 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/06/13/jvm/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/13/jvm/</guid>
        
        <category>Java</category>
        
        
      </item>
    
  </channel>
</rss>
